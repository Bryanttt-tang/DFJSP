# Event Time Fix for Dynamic RL Environment

## Problem Diagnosis

### Symptoms:
- Dynamic RL schedule has many idle gaps
- Performance stuck at makespan ~65 (vs ~40 for Perfect/Static RL)
- Episode length converges to 23 steps (suggesting agent learned to avoid WAIT)
- Schedule looks unreasonable even when arrival constraints removed

### Root Cause:

The issue was **automatic event_time advancement after scheduling actions** (lines 458-461):

```python
# WRONG: Auto-advancing event_time after every scheduling action
next_event_time = self._get_next_event_time()
if next_event_time > self.event_time and next_event_time != float('inf'):
    self._update_event_time_and_arrivals(next_event_time)
```

This caused two major problems:

#### Problem 1: Loss of Agent Control
- The environment auto-advanced time without agent's decision
- Agent couldn't control the tradeoff between:
  - **Schedule now**: Use current knowledge but risk suboptimal decisions
  - **Wait**: Reveal more jobs but increase makespan
- This is the CORE decision in online/dynamic scheduling!

#### Problem 2: Removed `event_time` from `start_time` Calculation
When you changed line 451 from:
```python
start_time = max(machine_available_time, job_ready_time, self.event_time)
```
to:
```python
start_time = max(machine_available_time, job_ready_time)  # WRONG!
```

This allowed **scheduling in the past**, creating idle gaps:

**Example:**
```
event_time = 20 (current simulation time)
machine_next_free[M0] = 10 (machine finished previous job)
job_ready_time = 12 (job arrived at t=12)

❌ start_time = max(10, 12) = 12  (schedules at t=12, but we're at t=20!)
   Creates 8-unit idle gap from 18 to 20

✅ start_time = max(10, 12, 20) = 20  (schedules at current time)
   No idle gap, continuous schedule
```

## The Fix

### 1. Keep `event_time` in `start_time` Calculation
```python
# CORRECT: Prevent scheduling in the past
start_time = max(machine_available_time, job_ready_time, self.event_time)
```

### 2. Remove Auto-Advancement of `event_time`
```python
# DO NOT auto-advance event_time after scheduling
# Let agent control time via WAIT action only
```

## How It Should Work

### Event-Driven Simulation Model:

```
Time:  0    5    10   15   20   25   30
       |----|----|----|----|----|----|
Event: J0   J1   J2        J3        J4
       ↓    ↓    ↓         ↓         ↓
```

### Agent Decision Flow:

**At t=0 (Initial):**
- `event_time = 0`
- `arrived_jobs = {J0, J1, J2}` (initial jobs)
- Agent can: Schedule J0/J1/J2, or WAIT

**Agent schedules J0 on M0 (0→4):**
- `machine_next_free[M0] = 4`
- `event_time = 0` (stays at 0, no auto-advance!)
- Agent still sees only J0, J1, J2

**Agent schedules J1 on M0 (4→11):**
- `start_time = max(4, 0, 0) = 4` ✅
- `machine_next_free[M0] = 11`
- `event_time = 0` (still at 0)

**Agent chooses WAIT:**
- Calls `_advance_to_next_arrival()`
- `next_event = min(next_arrival=15, next_machine_free=11) = 11`
- `event_time = 11` (advanced to M0 completion)
- No new jobs revealed (J3 arrives at t=15)

**Agent schedules J2 on M0 (11→18):**
- `start_time = max(11, 0, 11) = 11` ✅
- `event_time = 11` (no auto-advance)

**Agent chooses WAIT again:**
- `next_event = min(15, 18) = 15`
- `event_time = 15`
- **J3 arrives!** `arrived_jobs = {J0, J1, J2, J3}`

### Key Insight:

**`event_time` represents the agent's "knowledge horizon":**
- Operations can only start at or after `event_time` (no time travel)
- New jobs only revealed when `event_time` reaches their arrival time
- Agent explicitly controls when to advance `event_time` via WAIT action

## Expected Behavior After Fix

### Training Dynamics:
1. **Early episodes**: Agent over-waits (explores WAIT too much)
2. **Mid training**: Agent learns when to wait vs schedule
3. **Late training**: Agent balances:
   - Schedule aggressively when machines are idle
   - Wait strategically to batch jobs or avoid blocking

### Performance Metrics:
- Episode length should be **20-30 steps** (mix of schedule + wait)
- Episode reward should converge to **-40 to -50** (makespan)
- Schedule should have **minimal idle gaps**
- Should achieve **2-5% regret** vs MILP optimal

### Gantt Chart:
- Continuous schedules (no gaps)
- Smart waiting before dynamic jobs arrive
- Similar visual quality to Perfect Knowledge RL

## Verification Tests

### Test 1: No Auto-Advancement
```python
# After scheduling action
old_event_time = env.event_time
env.step(schedule_action)
assert env.event_time == old_event_time  # Should NOT change
```

### Test 2: No Past Scheduling
```python
# Schedule when event_time > machine_free
env.event_time = 20
env.machine_next_free['M0'] = 10
env.step(schedule_job_0_on_M0)
# Should schedule at t=20, not t=10
assert env.schedule['M0'][-1][1] >= 20  # start_time >= event_time
```

### Test 3: WAIT Advances Time
```python
old_event_time = env.event_time
env.step(WAIT_ACTION)
assert env.event_time > old_event_time  # Should advance
```

## Related Code Locations

- **Line 443-452**: `start_time` calculation (fixed)
- **Line 453-457**: Auto-advancement removed (fixed)
- **Line 357-365**: `_advance_to_next_arrival()` (correct - only called by WAIT)
- **Line 333-351**: `_get_next_event_time()` (correct)
- **Line 289-318**: `action_masks()` (correct - enforces arrivals)

## Summary

The fix restores the **fundamental principle of event-driven simulation**:
- **Scheduling actions**: Make decisions without advancing time
- **WAIT action**: Explicitly advance time to next event
- **event_time**: Prevents time travel and controls information revelation

This gives the agent full control over the explore-exploit tradeoff in online scheduling.
